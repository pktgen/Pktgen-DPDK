diff -ruN lua-5.3.5/Makefile lua.patched/Makefile
--- lua-5.3.5/Makefile	2016-12-20 10:26:08.000000000 -0600
+++ lua.patched/Makefile	2018-07-20 15:02:52.859487140 -0500
@@ -1,114 +1,11 @@
-# Makefile for installing Lua
-# See doc/readme.html for installation and customization instructions.
-
-# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================
-
-# Your platform. See PLATS for possible values.
-PLAT= none
-
-# Where to install. The installation starts in the src and doc directories,
-# so take care if INSTALL_TOP is not an absolute path. See the local target.
-# You may want to make INSTALL_LMOD and INSTALL_CMOD consistent with
-# LUA_ROOT, LUA_LDIR, and LUA_CDIR in luaconf.h.
-INSTALL_TOP= /usr/local
-INSTALL_BIN= $(INSTALL_TOP)/bin
-INSTALL_INC= $(INSTALL_TOP)/include
-INSTALL_LIB= $(INSTALL_TOP)/lib
-INSTALL_MAN= $(INSTALL_TOP)/man/man1
-INSTALL_LMOD= $(INSTALL_TOP)/share/lua/$V
-INSTALL_CMOD= $(INSTALL_TOP)/lib/lua/$V
-
-# How to install. If your install program does not support "-p", then
-# you may have to run ranlib on the installed liblua.a.
-INSTALL= install -p
-INSTALL_EXEC= $(INSTALL) -m 0755
-INSTALL_DATA= $(INSTALL) -m 0644
 #
-# If you don't have "install" you can use "cp" instead.
-# INSTALL= cp -p
-# INSTALL_EXEC= $(INSTALL)
-# INSTALL_DATA= $(INSTALL)
-
-# Other utilities.
-MKDIR= mkdir -p
-RM= rm -f
-
-# == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======
-
-# Convenience platforms targets.
-PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris
-
-# What to install.
-TO_BIN= lua luac
-TO_INC= lua.h luaconf.h lualib.h lauxlib.h lua.hpp
-TO_LIB= liblua.a
-TO_MAN= lua.1 luac.1
-
-# Lua version and release.
-V= 5.3
-R= $V.4
-
-# Targets start here.
-all:	$(PLAT)
-
-$(PLATS) clean:
-	cd src && $(MAKE) $@
-
-test:	dummy
-	src/lua -v
-
-install: dummy
-	cd src && $(MKDIR) $(INSTALL_BIN) $(INSTALL_INC) $(INSTALL_LIB) $(INSTALL_MAN) $(INSTALL_LMOD) $(INSTALL_CMOD)
-	cd src && $(INSTALL_EXEC) $(TO_BIN) $(INSTALL_BIN)
-	cd src && $(INSTALL_DATA) $(TO_INC) $(INSTALL_INC)
-	cd src && $(INSTALL_DATA) $(TO_LIB) $(INSTALL_LIB)
-	cd doc && $(INSTALL_DATA) $(TO_MAN) $(INSTALL_MAN)
-
-uninstall:
-	cd src && cd $(INSTALL_BIN) && $(RM) $(TO_BIN)
-	cd src && cd $(INSTALL_INC) && $(RM) $(TO_INC)
-	cd src && cd $(INSTALL_LIB) && $(RM) $(TO_LIB)
-	cd doc && cd $(INSTALL_MAN) && $(RM) $(TO_MAN)
-
-local:
-	$(MAKE) install INSTALL_TOP=../install
-
-none:
-	@echo "Please do 'make PLATFORM' where PLATFORM is one of these:"
-	@echo "   $(PLATS)"
-	@echo "See doc/readme.html for complete instructions."
-
-# make may get confused with test/ and install/
-dummy:
-
-# echo config parameters
-echo:
-	@cd src && $(MAKE) -s echo
-	@echo "PLAT= $(PLAT)"
-	@echo "V= $V"
-	@echo "R= $R"
-	@echo "TO_BIN= $(TO_BIN)"
-	@echo "TO_INC= $(TO_INC)"
-	@echo "TO_LIB= $(TO_LIB)"
-	@echo "TO_MAN= $(TO_MAN)"
-	@echo "INSTALL_TOP= $(INSTALL_TOP)"
-	@echo "INSTALL_BIN= $(INSTALL_BIN)"
-	@echo "INSTALL_INC= $(INSTALL_INC)"
-	@echo "INSTALL_LIB= $(INSTALL_LIB)"
-	@echo "INSTALL_MAN= $(INSTALL_MAN)"
-	@echo "INSTALL_LMOD= $(INSTALL_LMOD)"
-	@echo "INSTALL_CMOD= $(INSTALL_CMOD)"
-	@echo "INSTALL_EXEC= $(INSTALL_EXEC)"
-	@echo "INSTALL_DATA= $(INSTALL_DATA)"
+#   Copyright(c) 2015-2017 Intel Corporation. All rights reserved.
+#
+#   SPDX-License-Indentifier: BSD-3-Clause
+#
 
-# echo pkg-config data
-pc:
-	@echo "version=$R"
-	@echo "prefix=$(INSTALL_TOP)"
-	@echo "libdir=$(INSTALL_LIB)"
-	@echo "includedir=$(INSTALL_INC)"
+include $(RTE_SDK)/mk/rte.vars.mk
 
-# list targets that do not create files (but not all makes understand .PHONY)
-.PHONY: all $(PLATS) clean test install local none dummy echo pecho lecho
+DIRS-y += src
 
-# (end of Makefile)
+include $(RTE_SDK)/mk/rte.extsubdir.mk
diff -ruN lua-5.3.5/Makefile.lua lua.patched/Makefile.lua
--- lua-5.3.5/Makefile.lua	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/Makefile.lua	2018-07-20 15:02:52.859487140 -0500
@@ -0,0 +1,114 @@
+# Makefile for installing Lua
+# See doc/readme.html for installation and customization instructions.
+
+# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================
+
+# Your platform. See PLATS for possible values.
+PLAT= none
+
+# Where to install. The installation starts in the src and doc directories,
+# so take care if INSTALL_TOP is not an absolute path. See the local target.
+# You may want to make INSTALL_LMOD and INSTALL_CMOD consistent with
+# LUA_ROOT, LUA_LDIR, and LUA_CDIR in luaconf.h.
+INSTALL_TOP= /usr/local
+INSTALL_BIN= $(INSTALL_TOP)/bin
+INSTALL_INC= $(INSTALL_TOP)/include
+INSTALL_LIB= $(INSTALL_TOP)/lib
+INSTALL_MAN= $(INSTALL_TOP)/man/man1
+INSTALL_LMOD= $(INSTALL_TOP)/share/lua/$V
+INSTALL_CMOD= $(INSTALL_TOP)/lib/lua/$V
+
+# How to install. If your install program does not support "-p", then
+# you may have to run ranlib on the installed liblua.a.
+INSTALL= install -p
+INSTALL_EXEC= $(INSTALL) -m 0755
+INSTALL_DATA= $(INSTALL) -m 0644
+#
+# If you don't have "install" you can use "cp" instead.
+# INSTALL= cp -p
+# INSTALL_EXEC= $(INSTALL)
+# INSTALL_DATA= $(INSTALL)
+
+# Other utilities.
+MKDIR= mkdir -p
+RM= rm -f
+
+# == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======
+
+# Convenience platforms targets.
+PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris
+
+# What to install.
+TO_BIN= lua luac
+TO_INC= lua.h luaconf.h lualib.h lauxlib.h lua.hpp
+TO_LIB= liblua.a
+TO_MAN= lua.1 luac.1
+
+# Lua version and release.
+V= 5.3
+R= $V.4
+
+# Targets start here.
+all:	$(PLAT)
+
+$(PLATS) clean:
+	cd src && $(MAKE) $@
+
+test:	dummy
+	src/lua -v
+
+install: dummy
+	cd src && $(MKDIR) $(INSTALL_BIN) $(INSTALL_INC) $(INSTALL_LIB) $(INSTALL_MAN) $(INSTALL_LMOD) $(INSTALL_CMOD)
+	cd src && $(INSTALL_EXEC) $(TO_BIN) $(INSTALL_BIN)
+	cd src && $(INSTALL_DATA) $(TO_INC) $(INSTALL_INC)
+	cd src && $(INSTALL_DATA) $(TO_LIB) $(INSTALL_LIB)
+	cd doc && $(INSTALL_DATA) $(TO_MAN) $(INSTALL_MAN)
+
+uninstall:
+	cd src && cd $(INSTALL_BIN) && $(RM) $(TO_BIN)
+	cd src && cd $(INSTALL_INC) && $(RM) $(TO_INC)
+	cd src && cd $(INSTALL_LIB) && $(RM) $(TO_LIB)
+	cd doc && cd $(INSTALL_MAN) && $(RM) $(TO_MAN)
+
+local:
+	$(MAKE) install INSTALL_TOP=../install
+
+none:
+	@echo "Please do 'make PLATFORM' where PLATFORM is one of these:"
+	@echo "   $(PLATS)"
+	@echo "See doc/readme.html for complete instructions."
+
+# make may get confused with test/ and install/
+dummy:
+
+# echo config parameters
+echo:
+	@cd src && $(MAKE) -s echo
+	@echo "PLAT= $(PLAT)"
+	@echo "V= $V"
+	@echo "R= $R"
+	@echo "TO_BIN= $(TO_BIN)"
+	@echo "TO_INC= $(TO_INC)"
+	@echo "TO_LIB= $(TO_LIB)"
+	@echo "TO_MAN= $(TO_MAN)"
+	@echo "INSTALL_TOP= $(INSTALL_TOP)"
+	@echo "INSTALL_BIN= $(INSTALL_BIN)"
+	@echo "INSTALL_INC= $(INSTALL_INC)"
+	@echo "INSTALL_LIB= $(INSTALL_LIB)"
+	@echo "INSTALL_MAN= $(INSTALL_MAN)"
+	@echo "INSTALL_LMOD= $(INSTALL_LMOD)"
+	@echo "INSTALL_CMOD= $(INSTALL_CMOD)"
+	@echo "INSTALL_EXEC= $(INSTALL_EXEC)"
+	@echo "INSTALL_DATA= $(INSTALL_DATA)"
+
+# echo pkg-config data
+pc:
+	@echo "version=$R"
+	@echo "prefix=$(INSTALL_TOP)"
+	@echo "libdir=$(INSTALL_LIB)"
+	@echo "includedir=$(INSTALL_INC)"
+
+# list targets that do not create files (but not all makes understand .PHONY)
+.PHONY: all $(PLATS) clean test install local none dummy echo pecho lecho
+
+# (end of Makefile)
diff -ruN lua-5.3.5/src/liolib.c lua.patched/src/liolib.c
--- lua-5.3.5/src/liolib.c	2017-04-19 12:29:57.000000000 -0500
+++ lua.patched/src/liolib.c	2018-07-20 15:02:52.859487140 -0500
@@ -751,7 +751,7 @@
 }
 
 
-static void createstdfile (lua_State *L, FILE *f, const char *k,
+void createstdfile (lua_State *L, FILE *f, const char *k,
                            const char *fname) {
   LStream *p = newprefile(L);
   p->f = f;
diff -ruN lua-5.3.5/src/lstate.h lua.patched/src/lstate.h
--- lua-5.3.5/src/lstate.h	2017-04-19 12:39:34.000000000 -0500
+++ lua.patched/src/lstate.h	2018-07-20 15:02:52.859487140 -0500
@@ -199,6 +199,8 @@
   unsigned short nCcalls;  /* number of nested C calls */
   l_signalT hookmask;
   lu_byte allowhook;
+
+  void * private;
 };
 
 
diff -ruN lua-5.3.5/src/luaconf.h lua.patched/src/luaconf.h
--- lua-5.3.5/src/luaconf.h	2017-04-19 12:29:57.000000000 -0500
+++ lua.patched/src/luaconf.h	2018-07-20 15:02:52.859487140 -0500
@@ -61,7 +61,7 @@
 #if defined(LUA_USE_LINUX)
 #define LUA_USE_POSIX
 #define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
-#define LUA_USE_READLINE	/* needs some extra libraries */
+#undef LUA_USE_READLINE	/* needs some extra libraries */
 #endif
 
 
@@ -784,6 +784,26 @@
 
 
 
+/*
+@@ luai_writestring/luai_writeline define how 'print' prints its results.
+** They are only used in libraries and the stand-alone program. (The #if
+** avoids including 'stdio.h' everywhere.)
+*/
+#if defined(LUA_LIB) || defined(lua_c)
+#include <stdio.h>
+extern void * _get_stdout(void * L);
+#define lua_putstring(s)        (fwrite((s), sizeof(char), strlen(s), _get_stdout(L)), fflush(_get_stdout(L)))
+#define lua_writestring(s,l)   (fwrite((s), sizeof(char), (l), _get_stdout(L)), fflush(_get_stdout(L)))
+#define lua_writeline()  (lua_writestring("\n", 1), fflush(_get_stdout(L)))
+#endif
+
+/*
+@@ luai_writestringerror defines how to print error messages.
+** (A format string with one argument is enough for Lua...)
+*/
+extern void * _get_stderr(void * L);
+#define lua_writestringerror(s, p) \
+    (fprintf(_get_stderr(L), (s), (p)), fflush(_get_stderr(L)))
 
 
 #endif
diff -ruN lua-5.3.5/src/lua.h lua.patched/src/lua.h
--- lua-5.3.5/src/lua.h	2018-06-13 11:58:17.000000000 -0500
+++ lua.patched/src/lua.h	2018-07-20 15:02:52.859487140 -0500
@@ -437,6 +437,9 @@
 LUA_API int (lua_gethookmask) (lua_State *L);
 LUA_API int (lua_gethookcount) (lua_State *L);
 
+LUA_API void (lua_setprivate) (lua_State * L, void * val) ;
+LUA_API void * (lua_getprivate) (lua_State * L);
+
 
 struct lua_Debug {
   int event;
@@ -482,5 +485,6 @@
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
 
+void lua_callback_routine(char *);
 
 #endif
diff -ruN lua-5.3.5/src/lua_shell.c lua.patched/src/lua_shell.c
--- lua-5.3.5/src/lua_shell.c	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/src/lua_shell.c	2018-07-24 09:15:04.219666501 -0500
@@ -0,0 +1,448 @@
+/*
+ ** $Id: lua.c,v 1.205 2012/05/23 15:37:09 roberto Exp $
+ ** Lua stand-alone interpreter
+ ** See Copyright Notice in lua.h
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <signal.h>
+
+#define lua_c
+
+#include "lua.h"
+#include "lstate.h"
+
+#include "lauxlib.h"
+#include "lualib.h"
+#include "luasocket.h"
+#include "lua_shell.h"
+
+#if !defined(LUA_PROGNAME)
+#define LUA_PROGNAME		"lua-shell"
+#endif
+
+#if !defined(LUA_MAXINPUT)
+#define LUA_MAXINPUT		1024
+#endif
+
+#if !defined(LUA_INIT)
+#define LUA_INIT		"LUA_INIT"
+#endif
+
+#define LUA_INITVERSION  \
+	LUA_INIT "_" LUA_VERSION_MAJOR "_" LUA_VERSION_MINOR
+
+/*
+ ** lua_readline defines how to show a prompt and then read a line from
+ ** the standard input.
+ ** lua_saveline defines how to "save" a read line in a "history".
+ ** lua_freeline defines how to free a line read by lua_readline.
+ */
+#if defined(LUA_USE_READLINE)
+
+#include <readline/readline.h>
+#include <readline/history.h>
+#define lua_readline(L,b)	((void)L, ((b)=readline(NULL)) != NULL)
+#define lua_saveline(L,idx) \
+        if (lua_rawlen(L,idx) > 0)  /* non-empty line? */ \
+          add_history(lua_tostring(L, idx));  /* add it to history */
+#define lua_freeline(L,b)	((void)L, free(b))
+
+#elif !defined(lua_readline)
+
+#define lua_readline(L,b) \
+        ((void)L, fgets(b, LUA_MAXINPUT, _get_stdin(L)) != NULL)  /* get line */
+#define lua_saveline(L,idx)	{ (void)L; (void)idx; }
+#define lua_freeline(L,b)	{ (void)L; (void)b; }
+
+#endif
+
+static lua_State *globalL = NULL;
+
+static const char *progname = LUA_PROGNAME;
+
+static void
+lstop(lua_State *L, lua_Debug *ar) {
+	(void) ar; /* unused arg. */
+	lua_sethook(L, NULL, 0, 0);
+	luaL_error(L, "interrupted!");
+}
+
+static void
+laction(int i) {
+	signal(i, SIG_DFL ); /* if another SIGINT happens before lstop,
+	 terminate process (default action) */
+	lua_sethook(globalL, lstop, LUA_MASKCALL | LUA_MASKRET | LUA_MASKCOUNT, 1);
+}
+
+static void 
+l_message(lua_State *L, const char *pname, const char *msg) {
+	if (pname)
+		lua_writestringerror("%s: ", pname);
+	lua_writestringerror("%s\n", msg);
+}
+
+static int 
+report(lua_State *L, int status) {
+	if (status != LUA_OK && !lua_isnil(L, -1)) {
+		const char *msg = lua_tostring(L, -1);
+		if (msg == NULL )
+			msg = "(error object is not a string)";
+		l_message(L, progname, msg);
+		lua_pop(L, 1);
+		/* force a complete garbage collection in case of errors */
+		lua_gc(L, LUA_GCCOLLECT, 0);
+	}
+	return status;
+}
+
+#if 0
+/* the next function is called unprotected, so it must avoid errors */
+static void 
+finalreport(lua_State *L, int status) {
+	if (status != LUA_OK) {
+		const char *msg =
+				(lua_type(L, -1) == LUA_TSTRING) ? lua_tostring(L, -1) : NULL;
+		if (msg == NULL )
+			msg = "(error object is not a string)";
+		l_message(L, progname, msg);
+		lua_pop(L, 1);
+	}
+}
+#endif
+
+static int 
+traceback(lua_State *L) {
+	const char *msg = lua_tostring(L, 1);
+	if (msg)
+		luaL_traceback(L, L, msg, 1);
+	else if (!lua_isnoneornil(L, 1)) { /* is there an error object? */
+		if (!luaL_callmeta(L, 1, "__tostring")) /* try its 'tostring' metamethod */
+			lua_pushliteral(L, "(no error message)");
+	}
+	return 1;
+}
+
+static int 
+docall(lua_State *L, int narg, int nres) {
+	int status;
+	int base = lua_gettop(L) - narg; /* function index */
+
+	lua_pushcfunction(L, traceback);
+	/* push traceback function */
+	lua_insert(L, base); /* put it under chunk and args */
+	globalL = L; /* to be available to 'laction' */
+	signal(SIGINT, laction);
+	status = lua_pcall(L, narg, nres, base);
+	signal(SIGINT, SIG_DFL );
+	globalL = NULL;
+	lua_remove(L, base); /* remove traceback function */
+
+	return status;
+}
+
+#if 0
+static int 
+dofile(lua_State *L, const char *name) {
+	int status = luaL_loadfile(L, name);
+	if (status == LUA_OK)
+		status = docall(L, 0, 0);
+	return report(L, status);
+}
+
+static int 
+dostring(lua_State *L, const char *s, const char *name) {
+	int status = luaL_loadbuffer(L, s, strlen(s), name);
+	if (status == LUA_OK)
+		status = docall(L, 0, 0);
+	return report(L, status);
+}
+#endif
+
+int
+dolibrary(lua_State *L, const char *name) {
+	int status;
+	lua_getglobal(L, "require");
+	lua_pushstring(L, name);
+	status = docall(L, 1, 1); /* call 'require(name)' */
+	if (status == LUA_OK)
+		lua_setglobal(L, name); /* global[name] = require return */
+	return report(L, status);
+}
+
+/* mark in error messages for incomplete statements */
+#define EOFMARK		"<eof>"
+#define marklen		(sizeof(EOFMARK)/sizeof(char) - 1)
+
+#if 0
+static int
+incomplete(lua_State *L, int status) {
+	if (status == LUA_ERRSYNTAX) {
+		size_t lmsg;
+		const char *msg = lua_tolstring(L, -1, &lmsg);
+		if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
+			lua_pop(L, 1);
+			return 1;
+		}
+	}
+	return 0; /* else... */
+}
+
+static int
+pushline(lua_State *L, int firstline) {
+	char buffer[LUA_MAXINPUT];
+	char *b = buffer;
+	size_t l;
+
+	if (lua_readline(L, b) == 0)
+		return 0; 								/* no input */
+
+	l = strlen(b);
+	if (l > 0 && b[l - 1] == '\n')				/* line ends with newline? */
+		b[l - 1] = '\0';						/* remove it */
+	if (firstline && b[0] == '=')							/* first line starts with `=' ? */
+		lua_pushfstring(L, "return %s", b + 1); /* change it to `return' */
+	else
+		lua_pushstring(L, b);
+	lua_freeline(L, b);
+
+	return 1;
+}
+
+static int 
+loadline(lua_State *L) {
+	int status;
+
+	lua_settop(L, 0);
+	if (!pushline(L, 1))
+		return -1; /* no input */
+
+	for (;;) { /* repeat until gets a complete line */
+		size_t l;
+		const char *line = lua_tolstring(L, 1, &l);
+
+		status = luaL_loadbuffer(L, line, l, "=stdin");
+		if (!incomplete(L, status))
+			break; 					/* cannot try to add lines? */
+
+		if (!pushline(L, 0)) 		/* no more input? */
+			return -1;
+
+		lua_pushliteral(L, "\n");	/* add a new line... */
+		lua_insert(L, -2);			/* ...between the two lines */
+		lua_concat(L, 3);			/* join them */
+	}
+	lua_saveline(L, 1);
+	lua_remove(L, 1);				/* remove line */
+	return status;
+}
+
+static void
+dotty(lua_State *L) {
+	int status;
+	const char *oldprogname = progname;
+	progname = NULL;
+
+	while ((status = loadline(L)) != -1) {
+		if (status == LUA_OK)
+			status = docall(L, 0, LUA_MULTRET);
+		report(L, status);
+		if (status == LUA_OK && lua_gettop(L) > 0) { /* any result to print? */
+			luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
+			lua_getglobal(L, "print");
+			lua_insert(L, 1);
+			if (lua_pcall(L, lua_gettop(L)-1, 0, 0) != LUA_OK)
+				l_message(L, progname,
+						lua_pushfstring(L,
+								"error calling " LUA_QL("print") " (%s)",
+								lua_tostring(L, -1)));
+		}
+	}
+	lua_settop(L, 0); /* clear stack */
+	lua_writeline();
+
+	progname = oldprogname;
+}
+
+static int
+handle_luainit(lua_State *L) {
+	const char *name = "=" LUA_INITVERSION;
+	const char *init = getenv(name + 1);
+	if (init == NULL ) {
+		name = "=" LUA_INIT;
+		init = getenv(name + 1); /* try alternative name */
+	}
+	if (init == NULL )
+		return LUA_OK;
+	else if (init[0] == '@')
+		return dofile(L, init + 1);
+	else
+		return dostring(L, init, name);
+}
+#endif
+
+static newlib_t	newlibs[MAX_NEW_LIBS];
+static int newlibs_idx = 0;
+
+int
+lua_newlib_add(newlib_t n) {
+	if ( newlibs_idx >= MAX_NEW_LIBS )
+		return -1;
+	newlibs[newlibs_idx++] = n;
+	return 0;
+}
+
+void
+lua_newlibs_init(lua_State * L) {
+	int		i;
+
+	for(i = 0; i < newlibs_idx; i++)
+		newlibs[i](L);
+}
+
+#if 0
+static int
+pmain(lua_State *L) {
+
+	/* open standard libraries */
+	luaL_checkversion(L);
+
+	lua_newlibs_init(L);
+
+	if (handle_luainit(L) != LUA_OK)
+		return 0; /* error running LUA_INIT */
+
+	_set_stdfiles(L, luaL_getprivate(L));
+
+	dotty(L);
+
+	_reset_stdfiles(L);
+
+	lua_pushboolean(L, 1); /* signal no errors */
+
+	return 1;
+}
+
+int
+lua_shell(void * pServer) {
+	int status, result;
+	lua_State *L;
+
+	L = luaL_newstate(); /* create state */
+	if (L == NULL ) {
+		l_message(L, "Lua-Shell", "cannot create state: not enough memory");
+		return EXIT_FAILURE;
+	}
+	luaL_setprivate(L, pServer);
+
+	/* call 'pmain' in protected mode */
+	lua_pushcfunction(L, &pmain);
+	status = lua_pcall(L, 0, 1, 0);
+	result = lua_toboolean(L, -1);	/* get result */
+	finalreport(L, status);
+	lua_close(L);
+
+	return (result && status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+#endif
+
+/**************************************************************************//**
+*
+* execute_lua_string - Execute a Lua script buffer.
+*
+* DESCRIPTION
+* Execute a Lua script buffer or chunk of Lua p-code.
+*
+* RETURNS: o if OK and -1 if error.
+*
+* SEE ALSO:
+*/
+
+int
+execute_lua_string( lua_State * L, char * buffer )
+{
+	if ( (buffer == NULL) || (L == NULL) )
+		return -1;
+
+	if ( luaL_dostring(L, buffer) != 0 ) {
+		fprintf(stderr,"%s\n", lua_tostring(L,-1));
+		return -1;
+	}
+
+	return 0;
+}
+
+/**************************************************************************//**
+*
+* execute_lua_close - Close the Lua instance and free the resources.
+*
+* DESCRIPTION
+* Close the Lua instance and free the resources.
+*
+* RETURNS: N/A
+*
+* SEE ALSO:
+*/
+
+void
+execute_lua_close(lua_State * L)
+{
+	if ( L )
+		lua_close(L);
+}
+
+LUA_API void
+lua_setprivate(lua_State * L, void * val) {
+	L->private = val;
+}
+
+LUA_API void *
+lua_getprivate(lua_State * L) {
+	return L->private;
+}
+
+LUALIB_API void *
+luaL_getprivate(lua_State * L)
+{
+	return (L == NULL) ? NULL : lua_getprivate(L);
+}
+
+LUALIB_API int
+luaL_setprivate(lua_State * L, void * val)
+{
+	if ( L == NULL )
+		return -1;
+	lua_setprivate(L, val);
+	return 0;
+}
+
+void
+lua_set_stdfiles(lua_State * L, void * in, void * out, void * err)
+{
+	luaL_getmetatable(L, LUA_FILEHANDLE);
+	if (lua_isnil(L, -1)) {
+	  printf("luaL_getmetatable() returned NIL\n");
+	  return;
+	}
+
+	/* create (and set) default files */
+	createstdfile(L, in, IO_INPUT, "stdin");
+	createstdfile(L, out, IO_OUTPUT, "stdout");
+	createstdfile(L, err, NULL, "stderr");
+}
+
+void
+lua_reset_stdfiles(lua_State * L)
+{
+	luaL_getmetatable(L, LUA_FILEHANDLE);
+	if (lua_isnil(L, -1))
+	  return;
+
+	/* create (and set) default files */
+	createstdfile(L, stdin, IO_INPUT, "stdin");
+	createstdfile(L, stdout, IO_OUTPUT, "stdout");
+	createstdfile(L, stderr, NULL, "stderr");
+}
+
diff -ruN lua-5.3.5/src/lua_shell.h lua.patched/src/lua_shell.h
--- lua-5.3.5/src/lua_shell.h	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/src/lua_shell.h	2018-07-20 15:02:52.859487140 -0500
@@ -0,0 +1,43 @@
+/*-
+ * Copyright (c) <2010-2017>, Intel Corporation. All rights reserved.
+ *
+ * SPDX-License-Indentifier: BSD-3-Clause
+ */
+/* Created 2011 by Keith Wiles @ intel.com */
+
+#ifndef LUA_SHELL_H_
+#define LUA_SHELL_H_
+
+#define lua_c
+#include "lua.h"
+#include "lauxlib.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IO_PREFIX       "_IO_"
+#define IOPREF_LEN      (sizeof(IO_PREFIX)/sizeof(char) - 1)
+#define IO_INPUT        (IO_PREFIX "input")
+#define IO_OUTPUT       (IO_PREFIX "output")
+
+#define MAX_NEW_LIBS	16
+typedef void (*newlib_t)(lua_State * L);
+
+int lua_newlib_add(newlib_t n);
+void lua_newlibs_init(lua_State * L);
+
+LUALIB_API int luaL_setprivate(lua_State * L, void * val);
+LUALIB_API void * luaL_getprivate(lua_State * L);
+
+LUA_API void (lua_setprivate) (lua_State * L, void * val) ;
+LUA_API void * (lua_getprivate) (lua_State * L);
+
+void createstdfile (lua_State *L, FILE *f, const char *k,
+                           const char *fname);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LUA_SHELL_H_ */
diff -ruN lua-5.3.5/src/luasocket.c lua.patched/src/luasocket.c
--- lua-5.3.5/src/luasocket.c	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/src/luasocket.c	2018-07-20 15:02:52.859487140 -0500
@@ -0,0 +1,357 @@
+/*-
+ * Copyright (c) <2010-2017>, Intel Corporation. All rights reserved.
+ *
+ * SPDX-License-Indentifier: BSD-3-Clause
+ */
+
+/* Created 2010 by Keith Wiles @ intel.com */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <signal.h>
+#include <inttypes.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/queue.h>
+#include <netinet/in.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include <setjmp.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <libgen.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <assert.h>
+
+#include <rte_config.h>
+#include <rte_version.h>
+
+#include <rte_log.h>
+#include <rte_tailq.h>
+#include <rte_common.h>
+#include <rte_memory.h>
+#include <rte_memcpy.h>
+#include <rte_memzone.h>
+#include <rte_malloc.h>
+#include <rte_eal.h>
+#include <rte_per_lcore.h>
+#include <rte_launch.h>
+#include <rte_atomic.h>
+#include <rte_cycles.h>
+#include <rte_prefetch.h>
+#include <rte_lcore.h>
+#include <rte_branch_prediction.h>
+#include <rte_pci.h>
+#include <rte_random.h>
+#include <rte_timer.h>
+#include <rte_debug.h>
+#include <rte_ether.h>
+#include <rte_ethdev.h>
+#include <rte_ring.h>
+#include <rte_mempool.h>
+#include <rte_mbuf.h>
+
+#define lua_c
+#include "lua.h"
+#include "lualib.h"
+#include "lauxlib.h"
+
+#include "luasocket.h"
+#include "lua_shell.h"
+
+static lua_State * lstate;
+
+lua_State * lua_state_pointer(void) { return lstate; }
+
+extern void * lua_get_private(void * L);
+extern void lua_shell(void *);
+extern void lua_set_stdfiles(lua_State * L, FILE * in, FILE * out, FILE * err);
+extern void lua_reset_stdfiles(lua_State * L);
+extern int execute_lua_string(lua_State * L, char * str);
+extern void execute_lua_close(lua_State * L);
+
+static void
+_socket_open(luaServer_t * pServer)
+{
+	if ( pServer != NULL ) {
+		pServer->in		= fdopen(pServer->client_socket, "r");
+		pServer->out	= fdopen(pServer->client_socket, "w");
+		pServer->err	= fdopen(pServer->client_socket, "w");
+	}
+}
+
+static void
+_socket_close(luaServer_t * pServer)
+{
+	if ( pServer != NULL ) {
+		fclose(pServer->in);
+		fclose(pServer->out);
+		fclose(pServer->err);
+	}
+}
+
+void *
+_get_stdout(void * arg)
+{
+	luaServer_t * s;
+
+	if ( arg == NULL )
+		return stdout;
+	s = luaL_getprivate(arg);
+	if ( (s == NULL) || (s->out == NULL) )
+		return stdout;
+	return s->out;
+}
+
+void *
+_get_stdin(void * arg)
+{
+	luaServer_t * s;
+
+	if ( arg == NULL )
+		return stdin;
+	s = luaL_getprivate(arg);
+	if ( (s == NULL) || (s->in == NULL) )
+		return stdin;
+	return s->in;
+}
+
+void *
+_get_stderr(void * arg)
+{
+	luaServer_t * s;
+
+	if ( arg == NULL )
+		return stderr;
+	s = luaL_getprivate(arg);
+	if ( (s == NULL) || (s->err == NULL) )
+		return stderr;
+	return s->err;
+}
+
+void
+_set_stdfiles(lua_State * L, luaServer_t * pServer)
+{
+	lua_set_stdfiles(L, pServer->in, pServer->out, pServer->err);
+	signal(SIGPIPE, SIG_IGN);
+}
+
+void
+_reset_stdfiles(lua_State * L)
+{
+	signal(SIGPIPE, SIG_DFL);
+	lua_reset_stdfiles(L);
+}
+
+/**************************************************************************//**
+*
+* process_server_requests - Process a GUI or socket request.
+*
+* DESCRIPTION
+* Process the socket request using the list of commands above.
+*
+* RETURNS: N/A
+*
+* SEE ALSO:
+*/
+
+static void
+process_server_requests( luaServer_t * pServer )
+{
+	struct sockaddr_in ipaddr;
+	socklen_t	len;
+
+	pServer->client_socket = -1;
+	for(;;) {
+		len = sizeof(struct sockaddr_in);
+		if ( (pServer->client_socket = accept(pServer->server_socket, (struct sockaddr *)&ipaddr, &len)) < 0) {
+			perror("accept failed");
+			break;
+		}
+
+		if ( pServer->client_socket > 0 ) {
+
+			_socket_open(pServer);
+			lua_shell(pServer);
+			_socket_close(pServer);
+
+			close(pServer->client_socket);
+			pServer->client_socket = -1;
+		}
+	}
+
+	if ( pServer->server_socket > 0 ) {
+		close(pServer->server_socket);
+		pServer->server_socket = -1;
+	}
+}
+
+/**************************************************************************//**
+*
+* lua_server_create - Create the Lua server connection
+*
+* DESCRIPTION
+* Create the Lua Server connection.
+*
+* RETURNS: Return zero if OK or one if error.
+*
+* SEE ALSO:
+*/
+
+static int
+server_create( void * arg )
+{
+	luaServer_t	  * pServer = (luaServer_t *)arg;
+	char	* err_msg = NULL;
+	struct sockaddr_in ipaddr;
+	struct hostent * pHost;
+	int		linger = 1;
+
+	err_msg = "gethostbyname failed";
+	if( (pHost = gethostbyname(pServer->hostname)) == NULL )
+		goto error_exit;
+
+	err_msg = "Socket create failed";
+	if ( (pServer->server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0 )
+		goto error_exit;
+
+	memset(&ipaddr, 0, sizeof(ipaddr));
+	ipaddr.sin_family		= AF_INET;
+	ipaddr.sin_port			= htons(pServer->socket_port);
+	ipaddr.sin_addr.s_addr	= htonl(INADDR_ANY);
+
+	err_msg = "Setsockopt failed";
+	if (setsockopt(pServer->server_socket, SOL_SOCKET, SO_REUSEADDR, &linger, sizeof(linger)) == -1)
+		goto error_exit;
+
+	err_msg = "Bind failed";
+	if (bind(pServer->server_socket, (struct sockaddr *) &ipaddr, sizeof(ipaddr)) < 0)
+		goto error_exit;
+
+	err_msg = "Listen failed";
+	if (listen(pServer->server_socket, 5) < 0)
+		goto error_exit;
+
+	process_server_requests(pServer);
+
+	return 0;
+
+error_exit:
+	if ( pServer->server_socket != -1 )
+		close( pServer->server_socket );
+	pServer->server_socket = -1;
+	if ( err_msg ) {
+		perror(err_msg);
+		fflush(stdout);
+	}
+	return 1;
+}
+
+/**************************************************************************//**
+*
+* lua_server - Lua socket server thread
+*
+* DESCRIPTION
+* Lua socket server for Pktgen.
+*
+* RETURNS: void *
+*
+* SEE ALSO:
+*/
+
+static void *
+lua_server(void * arg) {
+
+	pthread_detach( pthread_self() );
+
+	server_create((luaServer_t *)arg);
+
+	return NULL;
+}
+
+/**************************************************************************//**
+*
+* lua_init_socket - Setup the system to process socket requests.
+*
+* DESCRIPTION
+* Zero out the socket structure and setup the callback to process commands.
+*
+* RETURNS: N/A
+*
+* SEE ALSO:
+*/
+
+int
+lua_init_socket(lua_State * L, pthread_t * pthread, char * hostname, int port)
+{
+	luaServer_t * p;
+	int		r;
+
+	p = luaL_getprivate(L);
+	if ( p == NULL )
+		return -1;
+
+	p->client_socket	= -1;
+	p->server_socket	= -1;
+	p->socket_port		= port;
+	p->hostname			= strdup( (hostname) ? hostname : "localhost" );
+
+	/* Split assert and function because using NDEBUG define will remove function */
+	r = pthread_create(pthread, NULL, lua_server, p);
+	assert( r == 0 );
+	return 0;
+}
+
+/**************************************************************************//**
+*
+* lua_create_instance - Open a Lua instance to be used later.
+*
+* DESCRIPTION
+* Create a Lua instance and init all of the libraries.
+*
+* RETURNS: N/A
+*
+* SEE ALSO:
+*/
+
+void *
+lua_create_instance(void)
+{
+	luaServer_t * p;
+	lua_State * L;
+
+	p = (luaServer_t *)calloc(1, sizeof(luaServer_t));
+	if (p == NULL)
+		return NULL;
+
+	L = luaL_newstate();
+	if ( L == NULL ) {
+		free(p);
+		return NULL;
+	}
+
+	p->client_socket	= -1;
+	p->server_socket	= -1;
+	p->in				= NULL;
+	p->out				= NULL;
+	p->err				= NULL;
+
+	luaL_setprivate(L, p);
+
+	// Make sure we display the copyright string for Lua.
+	lua_writestring(LUA_COPYRIGHT, strlen(LUA_COPYRIGHT));
+	lua_writeline();
+
+	lua_newlibs_init(L);
+
+	lstate = L;
+
+    return L;
+}
diff -ruN lua-5.3.5/src/luasocket.h lua.patched/src/luasocket.h
--- lua-5.3.5/src/luasocket.h	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/src/luasocket.h	2018-07-20 15:02:52.859487140 -0500
@@ -0,0 +1,36 @@
+/*-
+ * Copyright (c) <2010-2017>, Intel Corporation. All rights reserved.
+ *
+ * SPDX-License-Indentifier: BSD-3-Clause
+ */
+
+/* Created 2010 by Keith Wiles @ intel.com */
+
+#ifndef _LUA_SOCKET_H_
+#define _LUA_SOCKET_H_
+#include <pthread.h>
+#include "lua.h"
+
+
+#define MAX_LUA_BUFFER_SIZE		1024
+
+typedef struct luaServer_s {
+	int32_t		server_socket;			/**< Server socket descriptor */
+	int32_t		client_socket;			/**< Client socket descriptor */
+	int32_t		socket_port;
+	void	  * out, * in, * err;
+	char	  * hostname;
+	char		data[MAX_LUA_BUFFER_SIZE];
+} luaServer_t;
+
+void _lua_openlib(lua_State *L);
+void * _get_stdout(void * arg);
+void * _get_stdin(void * arg);
+void * _get_stderr(void * arg);
+void _set_stdfiles(lua_State * L, luaServer_t * pServer);
+void _reset_stdfiles(lua_State * L);
+
+int lua_init_socket(lua_State * L, pthread_t * pthread, char * hostname, int port);
+void * lua_create_instance(void);
+
+#endif /* _LUA_SOCKET_H_ */
diff -ruN lua-5.3.5/src/lua_version.map lua.patched/src/lua_version.map
--- lua-5.3.5/src/lua_version.map	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/src/lua_version.map	2018-07-20 15:02:52.859487140 -0500
@@ -0,0 +1,5 @@
+DPDK_18.02 {
+	global: *;
+
+	local: *;
+};
diff -ruN lua-5.3.5/src/Makefile lua.patched/src/Makefile
--- lua-5.3.5/src/Makefile	2018-06-25 12:46:36.000000000 -0500
+++ lua.patched/src/Makefile	2018-07-20 15:02:52.859487140 -0500
@@ -1,197 +1,46 @@
-# Makefile for building Lua
-# See ../doc/readme.html for installation and customization instructions.
+#
+#   Copyright(c) 2015-2016 Intel Corporation. All rights reserved.
+#
+#   SPDX-License-Indentifier: BSD-3-Clause
+
+#
+
+include $(RTE_SDK)/mk/rte.vars.mk
+
+# library name
+LIB = librte_lua.a
+
+EXPORT_MAP := lua_version.map
+LIBABIVER := 1
+
+# To overcome problems with FD6 more strict warnings gcc flags,
+# the following ones were removed:
+#  -Wstrict-prototypes
+#  -Wmissing-prototypes
+#  -Wold-style-definition
+#  -Wmissing-declarations
+#  -Wcast-qual
+WERROR_FLAGS := -W -Wall
+WERROR_FLAGS += -Wpointer-arith
+WERROR_FLAGS += -Wcast-align
+WERROR_FLAGS += -Wnested-externs
+WERROR_FLAGS += -Wno-cast-align
+
+CFLAGS += -O3 -g -DLUA_USE_LINUX -DUSE_64_BIT
+CFLAGS += $(WERROR_FLAGS) -I$(RTE_SRCDIR) -fno-stack-protector
+
+# all source are stored in SRCS-y
+SRCS-y := \
+	lapi.c lauxlib.c lbaselib.c lbitlib.c lcode.c lcorolib.c \
+	lctype.c ldblib.c ldebug.c ldo.c ldump.c lfunc.c lgc.c \
+	linit.c liolib.c llex.c lmathlib.c lmem.c loadlib.c \
+	lobject.c lopcodes.c loslib.c lparser.c lstate.c lutf8lib.c \
+	lstring.c lstrlib.c ltable.c ltablib.c ltm.c lua_shell.c \
+	lundump.c lvm.c lzio.c luasocket.c
+
+SYMLINK-y-include := lapi.h lauxlib.h lcode.h lctype.h ldebug.h \
+    ldo.h lfunc.h lgc.h llex.h llimits.h lmem.h lobject.h lopcodes.h \
+    lparser.h lprefix.h lstate.h lstring.h ltable.h ltm.h luaconf.h \
+    lua.h lualib.h lua_shell.h luasocket.h lundump.h lvm.h lzio.h
 
-# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================
-
-# Your platform. See PLATS for possible values.
-PLAT= none
-
-CC= gcc -std=gnu99
-CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) $(MYCFLAGS)
-LDFLAGS= $(SYSLDFLAGS) $(MYLDFLAGS)
-LIBS= -lm $(SYSLIBS) $(MYLIBS)
-
-AR= ar rcu
-RANLIB= ranlib
-RM= rm -f
-
-SYSCFLAGS=
-SYSLDFLAGS=
-SYSLIBS=
-
-MYCFLAGS=
-MYLDFLAGS=
-MYLIBS=
-MYOBJS=
-
-# == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======
-
-PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris
-
-LUA_A=	liblua.a
-CORE_O=	lapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \
-	lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o \
-	ltm.o lundump.o lvm.o lzio.o
-LIB_O=	lauxlib.o lbaselib.o lbitlib.o lcorolib.o ldblib.o liolib.o \
-	lmathlib.o loslib.o lstrlib.o ltablib.o lutf8lib.o loadlib.o linit.o
-BASE_O= $(CORE_O) $(LIB_O) $(MYOBJS)
-
-LUA_T=	lua
-LUA_O=	lua.o
-
-LUAC_T=	luac
-LUAC_O=	luac.o
-
-ALL_O= $(BASE_O) $(LUA_O) $(LUAC_O)
-ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)
-ALL_A= $(LUA_A)
-
-# Targets start here.
-default: $(PLAT)
-
-all:	$(ALL_T)
-
-o:	$(ALL_O)
-
-a:	$(ALL_A)
-
-$(LUA_A): $(BASE_O)
-	$(AR) $@ $(BASE_O)
-	$(RANLIB) $@
-
-$(LUA_T): $(LUA_O) $(LUA_A)
-	$(CC) -o $@ $(LDFLAGS) $(LUA_O) $(LUA_A) $(LIBS)
-
-$(LUAC_T): $(LUAC_O) $(LUA_A)
-	$(CC) -o $@ $(LDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS)
-
-clean:
-	$(RM) $(ALL_T) $(ALL_O)
-
-depend:
-	@$(CC) $(CFLAGS) -MM l*.c
-
-echo:
-	@echo "PLAT= $(PLAT)"
-	@echo "CC= $(CC)"
-	@echo "CFLAGS= $(CFLAGS)"
-	@echo "LDFLAGS= $(SYSLDFLAGS)"
-	@echo "LIBS= $(LIBS)"
-	@echo "AR= $(AR)"
-	@echo "RANLIB= $(RANLIB)"
-	@echo "RM= $(RM)"
-
-# Convenience targets for popular platforms
-ALL= all
-
-none:
-	@echo "Please do 'make PLATFORM' where PLATFORM is one of these:"
-	@echo "   $(PLATS)"
-
-aix:
-	$(MAKE) $(ALL) CC="xlc" CFLAGS="-O2 -DLUA_USE_POSIX -DLUA_USE_DLOPEN" SYSLIBS="-ldl" SYSLDFLAGS="-brtl -bexpall"
-
-bsd:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN" SYSLIBS="-Wl,-E"
-
-c89:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_C89" CC="gcc -std=c89"
-	@echo ''
-	@echo '*** C89 does not guarantee 64-bit integers for Lua.'
-	@echo ''
-
-
-freebsd:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX -DLUA_USE_READLINE -I/usr/include/edit" SYSLIBS="-Wl,-E -ledit" CC="cc"
-
-generic: $(ALL)
-
-linux:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX" SYSLIBS="-Wl,-E -ldl -lreadline"
-
-macosx:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_MACOSX" SYSLIBS="-lreadline"
-
-mingw:
-	$(MAKE) "LUA_A=lua53.dll" "LUA_T=lua.exe" \
-	"AR=$(CC) -shared -o" "RANLIB=strip --strip-unneeded" \
-	"SYSCFLAGS=-DLUA_BUILD_AS_DLL" "SYSLIBS=" "SYSLDFLAGS=-s" lua.exe
-	$(MAKE) "LUAC_T=luac.exe" luac.exe
-
-posix:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX"
-
-solaris:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN -D_REENTRANT" SYSLIBS="-ldl"
-
-# list targets that do not create files (but not all makes understand .PHONY)
-.PHONY: all $(PLATS) default o a clean depend echo none
-
-# DO NOT DELETE
-
-lapi.o: lapi.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
- lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lstring.h \
- ltable.h lundump.h lvm.h
-lauxlib.o: lauxlib.c lprefix.h lua.h luaconf.h lauxlib.h
-lbaselib.o: lbaselib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lbitlib.o: lbitlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lcode.o: lcode.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \
- llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
- ldo.h lgc.h lstring.h ltable.h lvm.h
-lcorolib.o: lcorolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lctype.o: lctype.c lprefix.h lctype.h lua.h luaconf.h llimits.h
-ldblib.o: ldblib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-ldebug.o: ldebug.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
- lobject.h ltm.h lzio.h lmem.h lcode.h llex.h lopcodes.h lparser.h \
- ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h
-ldo.o: ldo.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
- lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \
- lparser.h lstring.h ltable.h lundump.h lvm.h
-ldump.o: ldump.c lprefix.h lua.h luaconf.h lobject.h llimits.h lstate.h \
- ltm.h lzio.h lmem.h lundump.h
-lfunc.o: lfunc.c lprefix.h lua.h luaconf.h lfunc.h lobject.h llimits.h \
- lgc.h lstate.h ltm.h lzio.h lmem.h
-lgc.o: lgc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
- llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h
-linit.o: linit.c lprefix.h lua.h luaconf.h lualib.h lauxlib.h
-liolib.o: liolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-llex.o: llex.c lprefix.h lua.h luaconf.h lctype.h llimits.h ldebug.h \
- lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lgc.h llex.h lparser.h \
- lstring.h ltable.h
-lmathlib.o: lmathlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lmem.o: lmem.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
- llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h
-loadlib.o: loadlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lobject.o: lobject.c lprefix.h lua.h luaconf.h lctype.h llimits.h \
- ldebug.h lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h \
- lvm.h
-lopcodes.o: lopcodes.c lprefix.h lopcodes.h llimits.h lua.h luaconf.h
-loslib.o: loslib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lparser.o: lparser.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \
- llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
- ldo.h lfunc.h lstring.h lgc.h ltable.h
-lstate.o: lstate.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
- lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h llex.h \
- lstring.h ltable.h
-lstring.o: lstring.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \
- lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h
-lstrlib.o: lstrlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-ltable.o: ltable.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
- llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h
-ltablib.o: ltablib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-ltm.o: ltm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
- llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h ltable.h lvm.h
-lua.o: lua.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-luac.o: luac.c lprefix.h lua.h luaconf.h lauxlib.h lobject.h llimits.h \
- lstate.h ltm.h lzio.h lmem.h lundump.h ldebug.h lopcodes.h
-lundump.o: lundump.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \
- lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h \
- lundump.h
-lutf8lib.o: lutf8lib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
-lvm.o: lvm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
- llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h \
- ltable.h lvm.h
-lzio.o: lzio.c lprefix.h lua.h luaconf.h llimits.h lmem.h lstate.h \
- lobject.h ltm.h lzio.h
-
-# (end of Makefile)
+include $(RTE_SDK)/mk/rte.extlib.mk
diff -ruN lua-5.3.5/src/Makefile.lua lua.patched/src/Makefile.lua
--- lua-5.3.5/src/Makefile.lua	1969-12-31 18:00:00.000000000 -0600
+++ lua.patched/src/Makefile.lua	2018-07-20 15:02:52.859487140 -0500
@@ -0,0 +1,197 @@
+# Makefile for building Lua
+# See ../doc/readme.html for installation and customization instructions.
+
+# == CHANGE THE SETTINGS BELOW TO SUIT YOUR ENVIRONMENT =======================
+
+# Your platform. See PLATS for possible values.
+PLAT= none
+
+CC= gcc -std=gnu99
+CFLAGS= -O2 -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) $(MYCFLAGS)
+LDFLAGS= $(SYSLDFLAGS) $(MYLDFLAGS)
+LIBS= -lm $(SYSLIBS) $(MYLIBS)
+
+AR= ar rcu
+RANLIB= ranlib
+RM= rm -f
+
+SYSCFLAGS=
+SYSLDFLAGS=
+SYSLIBS=
+
+MYCFLAGS=
+MYLDFLAGS=
+MYLIBS=
+MYOBJS=
+
+# == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======
+
+PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris
+
+LUA_A=	liblua.a
+CORE_O=	lapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \
+	lmem.o lobject.o lopcodes.o lparser.o lstate.o lstring.o ltable.o \
+	ltm.o lundump.o lvm.o lzio.o
+LIB_O=	lauxlib.o lbaselib.o lbitlib.o lcorolib.o ldblib.o liolib.o \
+	lmathlib.o loslib.o lstrlib.o ltablib.o lutf8lib.o loadlib.o linit.o
+BASE_O= $(CORE_O) $(LIB_O) $(MYOBJS)
+
+LUA_T=	lua
+LUA_O=	lua.o
+
+LUAC_T=	luac
+LUAC_O=	luac.o
+
+ALL_O= $(BASE_O) $(LUA_O) $(LUAC_O)
+ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)
+ALL_A= $(LUA_A)
+
+# Targets start here.
+default: $(PLAT)
+
+all:	$(ALL_T)
+
+o:	$(ALL_O)
+
+a:	$(ALL_A)
+
+$(LUA_A): $(BASE_O)
+	$(AR) $@ $(BASE_O)
+	$(RANLIB) $@
+
+$(LUA_T): $(LUA_O) $(LUA_A)
+	$(CC) -o $@ $(LDFLAGS) $(LUA_O) $(LUA_A) $(LIBS)
+
+$(LUAC_T): $(LUAC_O) $(LUA_A)
+	$(CC) -o $@ $(LDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS)
+
+clean:
+	$(RM) $(ALL_T) $(ALL_O)
+
+depend:
+	@$(CC) $(CFLAGS) -MM l*.c
+
+echo:
+	@echo "PLAT= $(PLAT)"
+	@echo "CC= $(CC)"
+	@echo "CFLAGS= $(CFLAGS)"
+	@echo "LDFLAGS= $(SYSLDFLAGS)"
+	@echo "LIBS= $(LIBS)"
+	@echo "AR= $(AR)"
+	@echo "RANLIB= $(RANLIB)"
+	@echo "RM= $(RM)"
+
+# Convenience targets for popular platforms
+ALL= all
+
+none:
+	@echo "Please do 'make PLATFORM' where PLATFORM is one of these:"
+	@echo "   $(PLATS)"
+
+aix:
+	$(MAKE) $(ALL) CC="xlc" CFLAGS="-O2 -DLUA_USE_POSIX -DLUA_USE_DLOPEN" SYSLIBS="-ldl" SYSLDFLAGS="-brtl -bexpall"
+
+bsd:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN" SYSLIBS="-Wl,-E"
+
+c89:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_C89" CC="gcc -std=c89"
+	@echo ''
+	@echo '*** C89 does not guarantee 64-bit integers for Lua.'
+	@echo ''
+
+
+freebsd:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX -DLUA_USE_READLINE -I/usr/include/edit" SYSLIBS="-Wl,-E -ledit" CC="cc"
+
+generic: $(ALL)
+
+linux:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX" SYSLIBS="-Wl,-E -ldl -lreadline"
+
+macosx:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_MACOSX" SYSLIBS="-lreadline"
+
+mingw:
+	$(MAKE) "LUA_A=lua53.dll" "LUA_T=lua.exe" \
+	"AR=$(CC) -shared -o" "RANLIB=strip --strip-unneeded" \
+	"SYSCFLAGS=-DLUA_BUILD_AS_DLL" "SYSLIBS=" "SYSLDFLAGS=-s" lua.exe
+	$(MAKE) "LUAC_T=luac.exe" luac.exe
+
+posix:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX"
+
+solaris:
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN -D_REENTRANT" SYSLIBS="-ldl"
+
+# list targets that do not create files (but not all makes understand .PHONY)
+.PHONY: all $(PLATS) default o a clean depend echo none
+
+# DO NOT DELETE
+
+lapi.o: lapi.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
+ lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lstring.h \
+ ltable.h lundump.h lvm.h
+lauxlib.o: lauxlib.c lprefix.h lua.h luaconf.h lauxlib.h
+lbaselib.o: lbaselib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lbitlib.o: lbitlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lcode.o: lcode.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \
+ llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
+ ldo.h lgc.h lstring.h ltable.h lvm.h
+lcorolib.o: lcorolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lctype.o: lctype.c lprefix.h lctype.h lua.h luaconf.h llimits.h
+ldblib.o: ldblib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+ldebug.o: ldebug.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
+ lobject.h ltm.h lzio.h lmem.h lcode.h llex.h lopcodes.h lparser.h \
+ ldebug.h ldo.h lfunc.h lstring.h lgc.h ltable.h lvm.h
+ldo.o: ldo.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
+ lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h lopcodes.h \
+ lparser.h lstring.h ltable.h lundump.h lvm.h
+ldump.o: ldump.c lprefix.h lua.h luaconf.h lobject.h llimits.h lstate.h \
+ ltm.h lzio.h lmem.h lundump.h
+lfunc.o: lfunc.c lprefix.h lua.h luaconf.h lfunc.h lobject.h llimits.h \
+ lgc.h lstate.h ltm.h lzio.h lmem.h
+lgc.o: lgc.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
+ llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lstring.h ltable.h
+linit.o: linit.c lprefix.h lua.h luaconf.h lualib.h lauxlib.h
+liolib.o: liolib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+llex.o: llex.c lprefix.h lua.h luaconf.h lctype.h llimits.h ldebug.h \
+ lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lgc.h llex.h lparser.h \
+ lstring.h ltable.h
+lmathlib.o: lmathlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lmem.o: lmem.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
+ llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h
+loadlib.o: loadlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lobject.o: lobject.c lprefix.h lua.h luaconf.h lctype.h llimits.h \
+ ldebug.h lstate.h lobject.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h \
+ lvm.h
+lopcodes.o: lopcodes.c lprefix.h lopcodes.h llimits.h lua.h luaconf.h
+loslib.o: loslib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lparser.o: lparser.c lprefix.h lua.h luaconf.h lcode.h llex.h lobject.h \
+ llimits.h lzio.h lmem.h lopcodes.h lparser.h ldebug.h lstate.h ltm.h \
+ ldo.h lfunc.h lstring.h lgc.h ltable.h
+lstate.o: lstate.c lprefix.h lua.h luaconf.h lapi.h llimits.h lstate.h \
+ lobject.h ltm.h lzio.h lmem.h ldebug.h ldo.h lfunc.h lgc.h llex.h \
+ lstring.h ltable.h
+lstring.o: lstring.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \
+ lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h
+lstrlib.o: lstrlib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+ltable.o: ltable.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
+ llimits.h ltm.h lzio.h lmem.h ldo.h lgc.h lstring.h ltable.h lvm.h
+ltablib.o: ltablib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+ltm.o: ltm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
+ llimits.h ltm.h lzio.h lmem.h ldo.h lstring.h lgc.h ltable.h lvm.h
+lua.o: lua.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+luac.o: luac.c lprefix.h lua.h luaconf.h lauxlib.h lobject.h llimits.h \
+ lstate.h ltm.h lzio.h lmem.h lundump.h ldebug.h lopcodes.h
+lundump.o: lundump.c lprefix.h lua.h luaconf.h ldebug.h lstate.h \
+ lobject.h llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lstring.h lgc.h \
+ lundump.h
+lutf8lib.o: lutf8lib.c lprefix.h lua.h luaconf.h lauxlib.h lualib.h
+lvm.o: lvm.c lprefix.h lua.h luaconf.h ldebug.h lstate.h lobject.h \
+ llimits.h ltm.h lzio.h lmem.h ldo.h lfunc.h lgc.h lopcodes.h lstring.h \
+ ltable.h lvm.h
+lzio.o: lzio.c lprefix.h lua.h luaconf.h llimits.h lmem.h lstate.h \
+ lobject.h ltm.h lzio.h
+
+# (end of Makefile)
